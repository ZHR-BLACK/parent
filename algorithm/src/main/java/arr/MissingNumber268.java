package arr;

/**
 * @author ZHR
 * @version 1.0
 * @ClassName MissingNumber268
 * @Date 2019-07-01 17:25
 * 268. 缺失数字
 * 给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。
 * <p>
 * 示例 1:
 * 输入: [3,0,1]
 * 输出: 2
 * 示例 2:
 * <p>
 * 输入: [9,6,4,2,3,5,7,0,1]
 * 输出: 8
 **/
public class MissingNumber268 {

    /**
     * @param nums
     * @return int
     * 由于异或运算（XOR）满足结合律，并且对一个数进行两次完全相同的异或运算会得到原来的数，因此我们可以通过异或运算找到缺失的数字。
     * 1^1^2^2^3 = 3
     * <p>
     * 我们知道数组中有n个数，并且缺失的数在[0..n]中。因此我们可以先得到[0..n]的异或值，再将结果对数组中的每一个数进行一次异或运算。
     * 未缺失的数在 [0..n]和数组中各出现一次，因此异或后得到 0。而缺失的数字只在 [0..n]中出现了一次，在数组中没有出现，
     * 因此最终的异或结果即为这个缺失的数字。
     * <p>
     * 在编写代码时，由于 [0..n]恰好是这个数组的下标加上 n，因此可以用一次循环完成所有的异或运算，例如下面这个例子：
     * 下标	0	1	2	3
     * 数字	0	1	3	4
     * <p>
     * 可以将结果的初始值设为 nn，再对数组中的每一个数以及它的下标进行一个异或运算，即：
     * misssing=4∧(0∧0)∧(1∧1)∧(2∧3)∧(3∧4)
     * =(4∧4)∧(0∧0)∧(1∧1)∧(3∧3)∧2
     * =0∧0∧0∧0∧2
     * =2
     * 就得到了缺失的数字为 2。
     * <p>
     * 执行用时：2ms，在所有Java提交中击败了94.50%的用户
     * 内存消耗：48.2MB，在所有Java提交中击败了41.57%的用户
     * @Date 2019-07-01 17:27
     **/
    public int missingNumber(int[] nums) {
        int missing = nums.length;
        for (int i = 0; i < nums.length; i++) {
            missing ^= i ^ nums[i];
        }
        return missing;
    }

    /**
     * @param nums
     * @return int
     * 我们可以用 高斯求和公式 求出 [0..n][0..n] 的和，减去数组中所有数的和，就得到了缺失的数字。
     * <p>
     * 我们在线性时间内可以求出数组中所有数的和，并在常数时间内求出前 n+1n+1 个自然数（包括 0）的和，将后者减去前者，就得到了缺失的数字。
     * 时间复杂度：O(n)。求出数组中所有数的和的时间复杂度为 O(n)O(n)，高斯求和公式的时间复杂度为 O(1)，因此总的时间复杂度为 O(n)。
     * 空间复杂度：O(1)。算法中只用到了O(1)的额外空间，用来存储答案。
     * <p>
     * 执行用时：2ms，在所有Java提交中击败了94.50%的用户
     * 内存消耗：48.4MB，在所有Java提交中击败了34.58%的用户
     * @Date 2019-07-01 17:26
     **/
    public int missingNumber2(int[] nums) {
        int expectedSum = nums.length * (nums.length + 1) / 2;
        int actualSum = 0;
        for (int num : nums) {
            actualSum += num;
        }
        return expectedSum - actualSum;
    }

}
